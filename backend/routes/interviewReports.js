// routes/interviewRoutes.js
const express = require("express");
const multer = require("multer");
const pdfParse = require("pdf-parse");
const fs = require("fs");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const Interview = require("../models/Interview");
const User = require("../models/User");
const mongoose = require("mongoose");

const router = express.Router();
const upload = multer({
  dest: "uploads/",
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

if (!process.env.GEMINI_API_KEY) {
  console.warn("Warning: GEMINI_API_KEY not set in environment. Make sure .env contains it.");
}

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-pro" });

/**
 * Start Interview - Upload Resume & Generate Questions
 * Expects: multipart/form-data with `resume` file, `category`, `userId`
 */
router.post("/start", upload.single("resume"), async (req, res) => {
  try {
    const { category, userId } = req.body;

    if (!req.file) return res.status(400).json({ error: "Resume file is required" });
    if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ error: "Valid userId is required" });
    }

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    // Read PDF text
    const dataBuffer = fs.readFileSync(req.file.path);
    const pdfData = await pdfParse(dataBuffer);
    const resumeText = pdfData.text || "";

    // Build prompt to generate 5 crisp questions
    const prompt = `
You are an interviewer that produces exactly 5 concise, focused interview questions tailored to the resume and the category.
Do not add numbering or commentary. Return only one question per line.

Category: ${category}
Resume:
${resumeText}
    `.trim();

    const result = await model.generateContent(prompt);
    const rawText = result.response.text().trim();

    // parse lines into questions
    let questionsText = rawText
      .split(/\r?\n/)
      .map(q => q.replace(/^\d+[\).\s-]+/, "").trim())
      .filter(q => q.length > 0);

    // fallback: if model produced fewer than 5, attempt to split by sentences
    if (questionsText.length < 5) {
      const sentences = rawText.split(/[.?!]\s+/).map(s => s.trim()).filter(Boolean);
      questionsText = questionsText.concat(sentences).slice(0, 5);
    }

    if (questionsText.length === 0) throw new Error("No questions generated by Gemini");

    const interview = new Interview({
      userId,
      category,
      resumeText,
      questions: questionsText.map(q => ({ question: q })),
      totalScore: 0,
      accuracy: 0,
      status: "in-progress"
    });

    await interview.save();

    // cleanup file
    fs.unlink(req.file.path, (err) => {
      if (err) console.warn("Failed to delete uploaded file:", err);
    });

    res.json({
      interviewId: interview._id,
      questions: questionsText
    });
  } catch (err) {
    console.error("Interview start error:", err);
    res.status(500).json({ error: "Failed to start interview", details: err.message });
  }
});

/**
 * Submit answer to a question
 * Body: { interviewId, question, answer, userId }
 * Returns: { score, feedback, questionAccuracy, totalScore, overallAccuracy, questionIndex }
 */
router.post("/answer", async (req, res) => {
  try {
    const { interviewId, question, answer, userId } = req.body;

    if (!interviewId || !mongoose.Types.ObjectId.isValid(interviewId)) {
      return res.status(400).json({ error: "Valid interviewId required" });
    }

    if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ error: "Valid userId required" });
    }

    const interview = await Interview.findById(interviewId);
    if (!interview) return res.status(404).json({ error: "Interview not found" });
    if (String(interview.userId) !== String(userId)) {
      return res.status(403).json({ error: "User not authorized to submit answers for this interview" });
    }

    // Build evaluation prompt that asks for strict JSON
    const evalPrompt = `
You are an interview evaluator. Evaluate the candidate's answer using the resume and category context.
Return STRICT JSON with the following structure:
{ "score": <number 0-10>, "feedback": "<detailed but concise feedback in one paragraph>" }

Question:
${question}

Answer:
${answer}

Category:
${interview.category}

Resume:
${interview.resumeText}
    `.trim();

    const result = await model.generateContent(evalPrompt);
    const raw = result.response.text().trim();

    let evaluation = { score: 0, feedback: "No feedback" };
    try {
      // model should return JSON; try to parse. If text contains surrounding explanation, try to extract JSON substring.
      const firstBrace = raw.indexOf("{");
      const lastBrace = raw.lastIndexOf("}");
      const jsonString = firstBrace !== -1 && lastBrace !== -1 ? raw.slice(firstBrace, lastBrace + 1) : raw;
      evaluation = JSON.parse(jsonString);
    } catch (e) {
      console.warn("LLM output not valid JSON. Raw:", raw);
      // As a fallback, attempt to extract a number from the text for score
      const scoreMatch = raw.match(/"score"\s*:\s*([0-9]+(\.[0-9]+)?)/) || raw.match(/score\s*[:=]\s*([0-9]+(\.[0-9]+)?)/i);
      const score = scoreMatch ? Number(scoreMatch[1]) : 0;
      const feedbackMatch = raw.match(/"feedback"\s*:\s*"([^"]+)"/) || raw.match(/feedback\s*[:=]\s*["']?(.+)/i);
      const feedback = feedbackMatch ? (feedbackMatch[1] || raw).toString().slice(0, 1000) : raw.slice(0, 1000);
      evaluation = { score: Math.max(0, Math.min(10, score)), feedback };
    }

    // clamp score
    evaluation.score = Math.max(0, Math.min(10, Number(evaluation.score || 0)));
    const qIndex = interview.questions.findIndex(q => q.question === question);

    if (qIndex === -1) {
      return res.status(400).json({ error: "Question not found in interview" });
    }

    // update question
    interview.questions[qIndex].answer = answer;
    interview.questions[qIndex].score = evaluation.score;
    interview.questions[qIndex].feedback = evaluation.feedback;
    interview.questions[qIndex].accuracy = Math.round((evaluation.score / 10) * 100); // percentage
    interview.questions[qIndex].answeredAt = new Date();

    // recompute total score & overall accuracy
    interview.totalScore = interview.questions.reduce((acc, q) => acc + (q.score || 0), 0);
    const maxPossible = interview.questions.length * 10;
    interview.accuracy = Math.round((interview.totalScore / maxPossible) * 100);

    // if all answered, mark completed
    const allAnswered = interview.questions.every(q => q.answer && q.answer.length > 0 && q.score !== null);
    if (allAnswered) {
      interview.status = "completed";
      interview.completedAt = new Date();
    }

    await interview.save();

    res.json({
      score: evaluation.score,
      feedback: evaluation.feedback,
      questionAccuracy: interview.questions[qIndex].accuracy,
      questionIndex: qIndex,
      totalScore: interview.totalScore,
      overallAccuracy: interview.accuracy,
      status: interview.status
    });
  } catch (err) {
    console.error("Answer evaluation error:", err);
    res.status(500).json({ error: "Failed to evaluate answer", details: err.message });
  }
});

/**
 * Get Final Report by interview id
 */
router.get("/report/:id", async (req, res) => {
  try {
    const interview = await Interview.findById(req.params.id).populate("userId", "name email");
    if (!interview) return res.status(404).json({ error: "Interview not found" });
    res.json(interview);
  } catch (err) {
    console.error("Fetch report error:", err);
    res.status(500).json({ error: "Failed to fetch report" });
  }
});

module.exports = router;
